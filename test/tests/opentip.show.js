// Generated by CoffeeScript 1.3.3
var $,
  __hasProp = {}.hasOwnProperty;

$ = ender;

describe("Opentip - Appearing", function() {
  var adapter, opentip, triggerElementExists;
  adapter = Opentip.adapters["native"];
  opentip = null;
  triggerElementExists = true;
  beforeEach(function() {
    Opentip.adapter = adapter;
    return triggerElementExists = true;
  });
  afterEach(function() {
    var prop, _ref;
    for (prop in opentip) {
      if (!__hasProp.call(opentip, prop)) continue;
      if ((_ref = opentip[prop]) != null) {
        if (typeof _ref.restore === "function") {
          _ref.restore();
        }
      }
    }
    opentip.deactivate();
    return $(".opentip-container").remove();
  });
  describe("prepareToShow()", function() {
    beforeEach(function() {
      triggerElementExists = false;
      opentip = new Opentip(adapter.create("<div></div>"), "Test", {
        delay: 0
      });
      return sinon.stub(opentip, "_triggerElementExists", function() {
        return triggerElementExists;
      });
    });
    it("should always abort a hiding process", function() {
      sinon.stub(opentip, "_abortHiding");
      opentip.prepareToShow();
      return expect(opentip._abortHiding.callCount).to.be(1);
    });
    it("even when aborting because it's already visible", function() {
      sinon.stub(opentip, "_abortHiding");
      opentip.visible = true;
      opentip.prepareToShow();
      return expect(opentip._abortHiding.callCount).to.be(1);
    });
    it("should abort when already visible", function() {
      expect(opentip.preparingToShow).to.not.be.ok();
      opentip.visible = true;
      opentip.prepareToShow();
      expect(opentip.preparingToShow).to.not.be.ok();
      opentip.visible = false;
      opentip.prepareToShow();
      return expect(opentip.preparingToShow).to.be.ok();
    });
    it("should log that it's preparing to show", function() {
      sinon.stub(opentip, "debug");
      opentip.prepareToShow();
      return expect(opentip.debug.callCount).to.be(1);
    });
    it("should setup observers for 'showing'", function() {
      sinon.stub(opentip, "_setupObservers");
      opentip.prepareToShow();
      expect(opentip._setupObservers.callCount).to.be(1);
      return expect(opentip._setupObservers.getCall(0).args[0]).to.be("showing");
    });
    it("should start following mouseposition", function() {
      sinon.stub(opentip, "_followMousePosition");
      opentip.prepareToShow();
      return expect(opentip._followMousePosition.callCount).to.be(1);
    });
    it("should reposition itself «On se redresse!»", function() {
      sinon.stub(opentip, "reposition");
      opentip.prepareToShow();
      return expect(opentip.reposition.callCount).to.be(1);
    });
    return it("should call show() after the specified delay (50ms)", function(done) {
      opentip.options.delay = 0.05;
      sinon.stub(opentip, "show", function() {
        return done();
      });
      return opentip.prepareToShow();
    });
  });
  describe("show()", function() {
    beforeEach(function() {
      opentip = new Opentip(adapter.create("<div></div>"), "Test", {
        delay: 0
      });
      return sinon.stub(opentip, "_triggerElementExists", function() {
        return triggerElementExists;
      });
    });
    it("should clear all timeouts", function() {
      triggerElementExists = false;
      sinon.stub(opentip, "_clearTimeouts");
      opentip.show();
      return expect(opentip._clearTimeouts.callCount).to.be.above(0);
    });
    it("should clear all timeouts even if alrady visible", function() {
      triggerElementExists = false;
      sinon.stub(opentip, "_clearTimeouts");
      opentip.visible = true;
      opentip.show();
      return expect(opentip._clearTimeouts.callCount).to.be(1);
    });
    it("should abort if already visible", function() {
      triggerElementExists = false;
      sinon.stub(opentip, "debug");
      opentip.visible = true;
      opentip.show();
      return expect(opentip.debug.callCount).to.be(0);
    });
    it("should log that it's showing", function() {
      sinon.stub(opentip, "debug");
      opentip.show();
      expect(opentip.debug.callCount).to.be.above(1);
      return expect(opentip.debug.args[0][0]).to.be("Showing now.");
    });
    return it("should set visible to true and preparingToShow to false", function() {
      opentip.preparingToShow = true;
      opentip.show();
      expect(opentip.visible).to.be.ok();
      return expect(opentip.preparingToShow).to.not.be.ok();
    });
  });
  describe("events", function() {
    var element, event, testEvent, _i, _len, _ref, _results;
    element = "";
    beforeEach(function() {
      return element = document.createElement("div");
    });
    testEvent = function(opentip, event, done) {
      expect(opentip.visible).to.not.be.ok();
      $(element).trigger(event);
      expect(opentip.preparingToShow).to.be.ok();
      expect(opentip.visible).to.not.be.ok();
      return setTimeout(function() {
        try {
          expect(opentip.visible).to.be.ok();
          return done();
        } catch (e) {
          return done(e);
        }
      }, 2);
    };
    _ref = ["click", "mouseover", "focus"];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      event = _ref[_i];
      _results.push(it("should show on " + event, function(done) {
        opentip = new Opentip(element, "test", {
          delay: 0,
          showOn: event
        });
        sinon.stub(opentip, "_triggerElementExists", function() {
          return triggerElementExists;
        });
        return testEvent(opentip, event, done);
      }));
    }
    return _results;
  });
  return describe("visible", function() {
    var element, enderElement, span;
    enderElement = null;
    element = null;
    span = null;
    beforeEach(function() {
      enderElement = $("<div><div><span></span></div></div>");
      span = enderElement.find("span");
      element = enderElement.get(0);
      opentip = new Opentip(element, "test", {
        delay: 0,
        hideDelay: 0,
        showOn: "click",
        hideOn: "mouseout"
      });
      return sinon.stub(opentip, "_triggerElementExists", function() {
        return triggerElementExists;
      });
    });
    return it("should not hide when hovering child elements and hideOn == mouseout", function(done) {
      expect(opentip.visible).to.not.be.ok();
      enderElement.trigger("click");
      expect(opentip.preparingToShow).to.be.ok();
      expect(opentip.visible).to.not.be.ok();
      return setTimeout(function() {
        try {
          expect(opentip.visible).to.be.ok();
          enderElement.trigger("mouseout");
          enderElement.trigger("mouseover");
          setTimeout(function() {
            try {
              return expect(opentip.visible).to.be.ok();
            } catch (e) {
              return done(e);
            }
          }, 4);
          return done();
        } catch (e) {
          return done(e);
        }
      }, 4);
    });
  });
});
