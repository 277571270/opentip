// Generated by CoffeeScript 1.3.3
var $;

$ = ender;

describe("Opentip - Appearing", function() {
  var adapter, opentip, triggerElementExists;
  adapter = Opentip.adapters["native"];
  opentip = null;
  triggerElementExists = true;
  beforeEach(function() {
    Opentip.adapter = adapter;
    triggerElementExists = true;
    opentip = new Opentip(adapter.create("<div></div>"), "Test", {
      delay: 0
    });
    return sinon.stub(opentip, "_triggerElementExists", function() {
      return triggerElementExists;
    });
  });
  afterEach(function() {
    var prop, _base;
    for (prop in opentip) {
      if (typeof (_base = opentip[prop]).restore === "function") {
        _base.restore();
      }
    }
    return $(".opentip-container").remove();
  });
  describe("prepareToShow()", function() {
    beforeEach(function() {
      return triggerElementExists = false;
    });
    it("should always abort a hiding process", function() {
      sinon.stub(opentip, "_abortHiding");
      opentip.prepareToShow();
      return expect(opentip._abortHiding.callCount).to.be(1);
    });
    it("even when aborting because it's already visible", function() {
      sinon.stub(opentip, "_abortHiding");
      opentip.visible = true;
      opentip.prepareToShow();
      return expect(opentip._abortHiding.callCount).to.be(1);
    });
    it("should abort when already visible", function() {
      expect(opentip.preparingToShow).to.not.be.ok();
      opentip.visible = true;
      opentip.prepareToShow();
      expect(opentip.preparingToShow).to.not.be.ok();
      opentip.visible = false;
      opentip.prepareToShow();
      return expect(opentip.preparingToShow).to.be.ok();
    });
    it("should log that it's preparing to show", function() {
      sinon.stub(opentip, "debug");
      opentip.prepareToShow();
      return expect(opentip.debug.callCount).to.be(1);
    });
    it("should setup observers for 'showing'", function() {
      sinon.stub(opentip, "_setupObservers");
      opentip.prepareToShow();
      expect(opentip._setupObservers.callCount).to.be(1);
      return expect(opentip._setupObservers.getCall(0).args[0]).to.be("showing");
    });
    it("should start following mouseposition", function() {
      sinon.stub(opentip, "_followMousePosition");
      opentip.prepareToShow();
      return expect(opentip._followMousePosition.callCount).to.be(1);
    });
    it("should reposition itself «On se redresse!»", function() {
      sinon.stub(opentip, "reposition");
      opentip.prepareToShow();
      return expect(opentip.reposition.callCount).to.be(1);
    });
    return it("should call show() after the specified delay (50ms)", function(done) {
      opentip.options.delay = 0.05;
      sinon.stub(opentip, "show", function() {
        return done();
      });
      return opentip.prepareToShow();
    });
  });
  return describe("show()", function() {
    it("should clear all timeouts", function() {
      triggerElementExists = false;
      sinon.stub(opentip, "_clearTimeouts");
      opentip.show();
      return expect(opentip._clearTimeouts.callCount).to.be(1);
    });
    it("should clear all timeouts even if alrady visible", function() {
      triggerElementExists = false;
      sinon.stub(opentip, "_clearTimeouts");
      opentip.visible = true;
      opentip.show();
      return expect(opentip._clearTimeouts.callCount).to.be(1);
    });
    it("should abort if already visible", function() {
      triggerElementExists = false;
      sinon.stub(opentip, "debug");
      opentip.visible = true;
      opentip.show();
      return expect(opentip.debug.callCount).to.be(0);
    });
    it("should log that it's showing", function() {
      sinon.stub(opentip, "debug");
      opentip.show();
      expect(opentip.debug.callCount).to.be(1);
      return expect(opentip.debug.args[0][0]).to.be("Showing now.");
    });
    return it("should set visible to true and preparingToShow to false", function() {
      opentip.preparingToShow = true;
      opentip.show();
      expect(opentip.visible).to.be.ok();
      return expect(opentip.preparingToShow).to.not.be.ok();
    });
  });
});
