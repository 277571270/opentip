// Generated by CoffeeScript 1.3.3
var $;

$ = ender;

describe("Opentip - Appearing", function() {
  var adapter, opentip;
  adapter = Opentip.adapters["native"];
  opentip = null;
  beforeEach(function() {
    Opentip.adapter = adapter;
    return opentip = new Opentip(adapter.create("<div></div>"), "Test", {
      delay: 0
    });
  });
  afterEach(function() {
    var prop, _base, _results;
    _results = [];
    for (prop in opentip) {
      _results.push(typeof (_base = opentip[prop]).restore === "function" ? _base.restore() : void 0);
    }
    return _results;
  });
  describe("prepareToShow()", function() {
    it("should always abort a hiding process", function() {
      sinon.stub(opentip, "_abortHiding");
      opentip.prepareToShow();
      return expect(opentip._abortHiding.callCount).to.be(1);
    });
    it("even when aborting because it's already visible", function() {
      sinon.stub(opentip, "_abortHiding");
      opentip.visible = true;
      opentip.prepareToShow();
      return expect(opentip._abortHiding.callCount).to.be(1);
    });
    it("should abort when already visible", function() {
      expect(opentip.preparingToShow).to.not.be.ok();
      opentip.visible = true;
      opentip.prepareToShow();
      expect(opentip.preparingToShow).to.not.be.ok();
      opentip.visible = false;
      opentip.prepareToShow();
      return expect(opentip.preparingToShow).to.be.ok();
    });
    it("should log that it's preparing to show", function() {
      sinon.stub(opentip, "debug");
      opentip.prepareToShow();
      return expect(opentip.debug.callCount).to.be(1);
    });
    it("should setup observers for 'showing'", function() {
      sinon.stub(opentip, "_setupObservers");
      opentip.prepareToShow();
      expect(opentip._setupObservers.callCount).to.be(1);
      return expect(opentip._setupObservers.getCall(0).args[0]).to.be("showing");
    });
    it("should start following mouseposition", function() {
      sinon.stub(opentip, "_followMousePosition");
      opentip.prepareToShow();
      return expect(opentip._followMousePosition.callCount).to.be(1);
    });
    it("should reposition itself «On se redresse!»", function() {
      sinon.stub(opentip, "reposition");
      opentip.prepareToShow();
      return expect(opentip.reposition.callCount).to.be(1);
    });
    return it("should call show() after the specified delay (50ms)", function(done) {
      opentip.options.delay = 0.05;
      sinon.stub(opentip, "show", function() {
        return done();
      });
      return opentip.prepareToShow();
    });
  });
  return describe("show()", function() {
    it("should clear all timeouts", function() {
      sinon.stub(opentip, "_clearTimeouts");
      opentip.show();
      return expect(opentip._clearTimeouts.callCount).to.be(1);
    });
    it("should clear all timeouts even if alrady visible", function() {
      sinon.stub(opentip, "_clearTimeouts");
      opentip.visible = true;
      opentip.show();
      return expect(opentip._clearTimeouts.callCount).to.be(1);
    });
    it("should abort if already visible", function() {
      sinon.stub(opentip, "debug");
      opentip.visible = true;
      opentip.show();
      return expect(opentip.debug.callCount).to.be(0);
    });
    return it("should log that it's showing", function() {
      sinon.stub(opentip, "debug");
      opentip.show();
      return expect(opentip.debug.callCount).to.be(1);
    });
  });
});
