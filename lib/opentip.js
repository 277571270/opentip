// Generated by CoffeeScript 1.3.3
/*
#
# More info at [www.opentip.org](http://www.opentip.org)
# 
# Copyright (c) 2012, Matias Meno  
# Graphics by Tjandra Mayerhold
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
*/

var Opentip,
  __slice = [].slice;

Opentip = (function() {

  Opentip.prototype.STICKS_OUT_TOP = 1;

  Opentip.prototype.STICKS_OUT_BOTTOM = 2;

  Opentip.prototype.STICKS_OUT_LEFT = 1;

  Opentip.prototype.STICKS_OUT_RIGHT = 2;

  Opentip.prototype.lastTipId = 0;

  Opentip.prototype.lastZIndex = 100;

  Opentip.prototype["class"] = {
    container: "opentip-container",
    completelyHidden: "completely-hidden",
    loading: "loading",
    fixed: "fixed",
    showEffectPrefix: "show-effect-",
    hideEffectPrefix: "hide-effect-",
    stylePrefix: "style-"
  };

  function Opentip(element, content, title, options) {
    var optionSources, styleOptions, _ref,
      _this = this;
    this.id = ++this.lastTipId;
    this.adapter = Opentip.adapter;
    this.triggerElement = this.adapter.wrap(element);
    if (this.triggerElement.length > 1) {
      throw new Error("You can't call Opentip on multiple elements.");
    }
    if (this.triggerElement.length < 1) {
      throw new Error("Invalid element.");
    }
    this.loaded = false;
    this.loading = false;
    this.visible = false;
    this.waitingToShow = false;
    this.waitingToHide = false;
    this.lastPosition = {
      left: 0,
      top: 0
    };
    this.dimensions = [100, 50];
    this.content = "";
    options = this.adapter.clone(options);
    if (typeof content === "object") {
      options = content;
      content = title = void 0;
    } else if (typeof title === "object") {
      options = title;
      title = void 0;
    }
    if (title != null) {
      options.title = title;
    }
    if (content != null) {
      this.setContent(content);
    }
    if (!options.style) {
      options.style = Opentip.defaultStyle;
    }
    styleOptions = this.adapter.extend({}, Opentip.styles.standard);
    optionSources = [];
    optionSources.push(Opentip.styles.standard);
    if (options.style !== "standard") {
      optionSources.push(Opentip.styles[options.style]);
    }
    optionSources.push(options);
    options = (_ref = this.adapter).extend.apply(_ref, [{}].concat(__slice.call(optionSources)));
    if (options.ajax && !(options.ajax.url != null)) {
      if (this.adapter.tagName(this.triggerElement) === "A") {
        if (typeof options.ajax !== "object") {
          options.ajax = {};
        }
        options.ajax.url = this.adapter.attr(this.triggerElement, "href");
      } else {
        options.ajax = false;
      }
    }
    if (options.showOn === "click" && this.adapter.tagName(this.triggerElement) === "A") {
      this.adapter.observe(this.triggerElement, "click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        return e.stopped = true;
      });
    }
    if (options.target) {
      options.fixed = true;
    }
    if (options.stem === true) {
      options.stem = options.tipJoint;
    }
    if (options.target === true) {
      options.target = this.triggerElement;
    } else if (options.target) {
      options.target = this.adapter.wrap(options.target);
    }
    this.currentStemPosition = options.stem;
    if (options.delay == null) {
      options.delay = options.showOn === "mouseover" ? 0.2 : 0;
    }
    if (options.targetJoint == null) {
      options.targetJoint = [];
      options.targetJoint[0] = options.tipJoint[0] === "left" ? "right" : options.tipJoint[0] === "right" ? "left" : "center";
      options.targetJoint[1] = options.tipJoint[1] === "top" ? "bottom" : options.tipJoint[1] === "bottom" ? "top" : "middle";
    }
    this.showTriggersWhenHidden = [];
    this.showTriggersWhenVisible = [];
    this.hideTriggers = [];
    if (options.showOn && options.showOn !== "creation") {
      this.showTriggersWhenHidden.push({
        element: this.triggerElement,
        event: options.showOn
      });
    }
    this.options = options;
    this.adapter.domReady(function() {
      return _this._init();
    });
  }

  Opentip.prototype._init = function() {
    var hideOn, hideOnEvent, hideTrigger, hideTriggerElement, i, methodToBind, _i, _j, _len, _len1, _ref, _ref1,
      _this = this;
    this._buildContainer();
    if (this.options.hideTrigger) {
      if (!(this.options.hideTrigger instanceof Array)) {
        this.options.hideTrigger = [this.options.hideTrigger];
      }
      _ref = this.options.hideTrigger;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        hideTrigger = _ref[i];
        hideOnEvent = null;
        hideTriggerElement = null;
        hideOn = this.options.hideOn instanceof Array ? this.options.hideOn[i] : this.options.hideOn;
        if (typeof hideTrigger === "string") {
          switch (hideTrigger) {
            case "trigger":
              hideOnEvent = hideOn || "mouseout";
              hideTriggerElement = this.triggerElement;
              break;
            case "tip":
              hideOnEvent = hideOn || "mouseover";
              hideTriggerElement = this.container;
              break;
            case "target":
              hideOnEvent = hideOn || "mouseover";
              hideTriggerElement = this.options.target;
              break;
            case "closeButton":
              break;
            default:
              throw new Error("Unknown hide trigger: " + hideTrigger + ".");
          }
        } else {
          hideOnEvent = hideOn || "mouseover";
          hideTriggerElement = this.adapter.wrap(hideTrigger);
        }
        if (hideTriggerElement) {
          this.hideTriggers.push({
            element: hideTriggerElement,
            event: hideOnEvent
          });
          if (hideOnEvent === "mouseout") {
            this.showTriggersWhenVisible.push({
              element: hideTriggerElement,
              event: "mouseover"
            });
          }
        }
      }
    }
    this.bound = {};
    _ref1 = ["prepareToShow", "prepareToHide", "show", "hide", "reposition"];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      methodToBind = _ref1[_j];
      this.bound[methodToBind] = (function() {
        return _this[methodToBind].apply(_this, arguments);
      });
    }
    this.activate();
    if (this.options.showOn === "creation") {
      return this.prepareToShow();
    }
  };

  Opentip.prototype._buildContainer = function() {
    this.container = this.adapter.create("<div id=\"opentip-" + this.id + "\" class=\"" + this["class"].container + " " + this["class"].completelyHidden + " " + this["class"].stylePrefix + this.options.className + "\"></div>");
    if (this.options.ajax) {
      this.adapter.addClass(this.container, this["class"].loading);
    }
    if (this.options.fixed) {
      this.adapter.addClass(this.container, this["class"].fixed);
    }
    if (this.options.showEffect) {
      this.adapter.addClass(this.container, "" + this["class"].showEffectPrefix + this.options.showEffect);
    }
    if (this.options.hideEffect) {
      return this.adapter.addClass(this.container, "" + this["class"].hideEffectPrefix + this.options.hideEffect);
    }
  };

  Opentip.prototype.setContent = function(content) {
    this.content = content;
    if (this.visible) {
      return this._updateElementContent();
    }
  };

  Opentip.prototype._updateElementContent = function() {};

  Opentip.prototype.activate = function() {
    return this._setupObservers("hiding", "hidden");
  };

  Opentip.prototype.deactivate = function() {
    this.debug("Deactivating tooltip.");
    this.hide();
    return this._setupObservers("hidden");
  };

  Opentip.prototype._setupObservers = function() {
    var state, states, trigger, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _results;
    states = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    _results = [];
    for (_i = 0, _len = states.length; _i < _len; _i++) {
      state = states[_i];
      switch (state) {
        case "showing":
          _ref = this.hideTriggers;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            trigger = _ref[_j];
            this.adapter.observe(trigger.element, trigger.event, this.bound.prepareToHide);
          }
          _ref1 = this.showTriggersWhenHidden;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            trigger = _ref1[_k];
            this.adapter.stopObserving(trigger.element, trigger.event, this.bound.prepareToShow);
          }
          this.adapter.observe((document.onresize != null ? document : window), "resize", this.bound.reposition);
          _results.push(this.adapter.observe(window, "scroll", this.bound.reposition));
          break;
        case "visible":
          _results.push((function() {
            var _l, _len3, _results1;
            _results1 = [];
            for (_l = 0, _len3 = showTriggersWhenVisible.length; _l < _len3; _l++) {
              trigger = showTriggersWhenVisible[_l];
              _results1.push(this.adapter.observe(trigger.element, trigger.event, this.bound.prepareToShow));
            }
            return _results1;
          }).call(this));
          break;
        case "hiding":
          _ref2 = this.showTriggersWhenHidden;
          for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
            trigger = _ref2[_l];
            this.adapter.observe(trigger.element, trigger.event, this.bound.prepareToShow);
          }
          _ref3 = this.hideTriggers;
          for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
            trigger = _ref3[_m];
            this.adapter.stopObserving(trigger.element, trigger.event, this.bound.prepareToHide);
          }
          this.adapter.stopObserving((document.onresize != null ? document : window), "resize", this.bound.reposition);
          _results.push(this.adapter.stopObserving(window, "scroll", this.bound.reposition));
          break;
        case "hidden":
          _results.push((function() {
            var _len5, _n, _ref4, _results1;
            _ref4 = this.showTriggersWhenVisible;
            _results1 = [];
            for (_n = 0, _len5 = _ref4.length; _n < _len5; _n++) {
              trigger = _ref4[_n];
              _results1.push(this.adapter.stopObserving(trigger.element, trigger.event, this.bound.prepareToShow));
            }
            return _results1;
          }).call(this));
          break;
        default:
          throw new Error("Unknown state: " + state);
      }
    }
    return _results;
  };

  Opentip.prototype.prepareToShow = function() {};

  Opentip.prototype.show = function() {};

  Opentip.prototype.prepareToHide = function() {};

  Opentip.prototype.hide = function() {};

  Opentip.prototype.reposition = function() {};

  return Opentip;

})();

Opentip.prototype.ucfirst = function(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
};

Opentip.prototype.sanitizePosition = function(arrayPosition) {
  var position, positionString;
  if (arrayPosition instanceof Array) {
    positionString = "";
    if (arrayPosition[0] === "center") {
      positionString = arrayPosition[1];
    } else if (arrayPosition[1] === "middle") {
      positionString = arrayPosition[0];
    } else {
      positionString = arrayPosition[1] + this.ucfirst(arrayPosition[0]);
    }
  } else if (typeof arrayPosition === "string") {
    positionString = arrayPosition;
  }
  position = Opentip.position[positionString];
  if (position == null) {
    throw "Unknown position: " + positionString;
  }
  return position;
};

Opentip.prototype.debug = function() {
  if (this.debugging && ((typeof console !== "undefined" && console !== null ? console.debug : void 0) != null)) {
    return console.debug.apply(console, arguments);
  }
};

Opentip.version = "2.0.0-dev";

Opentip.debugging = false;

Opentip.adapters = {};

Opentip.adapter = null;

Opentip.documentIsLoaded = false;

Opentip.position = {
  top: 0,
  topRight: 1,
  right: 2,
  bottomRight: 3,
  bottom: 4,
  bottomLeft: 5,
  left: 6,
  topLeft: 7
};

Opentip.styles = {
  standard: {
    title: void 0,
    className: "standard",
    stem: false,
    delay: null,
    hideDelay: 0.1,
    fixed: false,
    showOn: "mouseover",
    hideTrigger: "trigger",
    hideOn: null,
    offset: [0, 0],
    containInViewport: true,
    autoOffset: true,
    showEffect: "appear",
    hideEffect: "fade",
    showEffectDuration: 0.3,
    hideEffectDuration: 0.2,
    stemSize: 8,
    tipJoint: ["left", "top"],
    target: null,
    targetJoint: null,
    ajax: false,
    group: null,
    escapeHtml: false,
    style: null
  },
  slick: {
    className: "slick",
    stem: true
  },
  rounded: {
    className: "rounded",
    stem: true
  },
  glass: {
    className: "glass"
  }
};

Opentip.defaultStyle = "standard";
