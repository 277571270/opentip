// Generated by CoffeeScript 1.3.3
/*
#
# More info at [www.opentip.org](http://www.opentip.org)
# 
# Copyright (c) 2012, Matias Meno  
# Graphics by Tjandra Mayerhold
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
*/

var Opentip, i, position, vendors, _i, _len, _ref,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __hasProp = {}.hasOwnProperty;

Opentip = (function() {

  Opentip.prototype.STICKS_OUT_TOP = 1;

  Opentip.prototype.STICKS_OUT_BOTTOM = 2;

  Opentip.prototype.STICKS_OUT_LEFT = 1;

  Opentip.prototype.STICKS_OUT_RIGHT = 2;

  Opentip.prototype["class"] = {
    container: "opentip-container",
    hidden: "hidden",
    hiding: "hiding",
    goingToShow: "going-to-show",
    showing: "showing",
    visible: "visible",
    loading: "loading",
    fixed: "fixed",
    showEffectPrefix: "show-effect-",
    hideEffectPrefix: "hide-effect-",
    stylePrefix: "style-"
  };

  function Opentip(element, content, title, options) {
    var optionSources, prop, styleOptions, _i, _len, _ref, _ref1,
      _this = this;
    this.id = ++Opentip.lastId;
    this.debug("Creating Opentip.");
    this.adapter = Opentip.adapter;
    this.triggerElement = this.adapter.wrap(element);
    if (this.triggerElement.length > 1) {
      throw new Error("You can't call Opentip on multiple elements.");
    }
    if (this.triggerElement.length < 1) {
      throw new Error("Invalid element.");
    }
    this.loaded = false;
    this.loading = false;
    this.visible = false;
    this.waitingToShow = false;
    this.waitingToHide = false;
    this.lastPosition = {
      left: 0,
      top: 0
    };
    this.dimensions = [100, 50];
    this.content = "";
    options = this.adapter.clone(options);
    if (typeof content === "object") {
      options = content;
      content = title = void 0;
    } else if (typeof title === "object") {
      options = title;
      title = void 0;
    }
    if (title != null) {
      options.title = title;
    }
    if (content != null) {
      this.setContent(content);
    }
    if (!options.style) {
      options.style = Opentip.defaultStyle;
    }
    styleOptions = this.adapter.extend({}, Opentip.styles.standard);
    optionSources = [];
    optionSources.push(Opentip.styles.standard);
    if (options.style !== "standard") {
      optionSources.push(Opentip.styles[options.style]);
    }
    optionSources.push(options);
    options = (_ref = this.adapter).extend.apply(_ref, [{}].concat(__slice.call(optionSources)));
    if (options.hideTrigger) {
      options.hideTriggers.push(options.hideTrigger);
    }
    _ref1 = ["tipJoint", "targetJoint", "stem"];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      prop = _ref1[_i];
      options[prop] = this.sanitizePosition(options[prop]);
    }
    if (options.ajax && !(options.ajax.url != null)) {
      if (this.adapter.tagName(this.triggerElement) === "A") {
        if (typeof options.ajax !== "object") {
          options.ajax = {};
        }
        options.ajax.url = this.adapter.attr(this.triggerElement, "href");
      } else {
        options.ajax = false;
      }
    }
    if (options.showOn === "click" && this.adapter.tagName(this.triggerElement) === "A") {
      this.adapter.observe(this.triggerElement, "click", function(e) {
        e.preventDefault();
        e.stopPropagation();
        return e.stopped = true;
      });
    }
    if (options.target) {
      options.fixed = true;
    }
    if (options.stem === true) {
      options.stem = options.tipJoint;
    }
    if (options.target === true) {
      options.target = this.triggerElement;
    } else if (options.target) {
      options.target = this.adapter.wrap(options.target);
    }
    this.currentStemPosition = options.stem;
    if (options.delay == null) {
      options.delay = options.showOn === "mouseover" ? 0.2 : 0;
    }
    if (options.targetJoint == null) {
      options.targetJoint = this.flipPosition(options.tipJoint);
    }
    this.showTriggersWhenHidden = [];
    this.showTriggersWhenVisible = [];
    this.hideTriggers = [];
    if (options.showOn && options.showOn !== "creation") {
      this.showTriggersWhenHidden.push({
        element: this.triggerElement,
        event: options.showOn
      });
    }
    this.options = options;
    this.adapter.domReady(function() {
      return _this._init();
    });
  }

  Opentip.prototype._init = function() {
    var hideOn, hideOnEvent, hideTrigger, hideTriggerElement, i, methodToBind, _i, _j, _len, _len1, _ref, _ref1,
      _this = this;
    this._buildContainer();
    _ref = this.options.hideTriggers;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      hideTrigger = _ref[i];
      hideOnEvent = null;
      hideTriggerElement = null;
      hideOn = this.options.hideOn instanceof Array ? this.options.hideOn[i] : this.options.hideOn;
      if (typeof hideTrigger === "string") {
        switch (hideTrigger) {
          case "trigger":
            hideOnEvent = hideOn || "mouseout";
            hideTriggerElement = this.triggerElement;
            break;
          case "tip":
            hideOnEvent = hideOn || "mouseover";
            hideTriggerElement = this.container;
            break;
          case "target":
            hideOnEvent = hideOn || "mouseover";
            hideTriggerElement = this.options.target;
            break;
          case "closeButton":
            break;
          default:
            throw new Error("Unknown hide trigger: " + hideTrigger + ".");
        }
      } else {
        hideOnEvent = hideOn || "mouseover";
        hideTriggerElement = this.adapter.wrap(hideTrigger);
      }
      if (hideTriggerElement) {
        this.hideTriggers.push({
          element: hideTriggerElement,
          event: hideOnEvent
        });
        if (hideOnEvent === "mouseout") {
          this.showTriggersWhenVisible.push({
            element: hideTriggerElement,
            event: "mouseover"
          });
        }
      }
    }
    this.bound = {};
    _ref1 = ["prepareToShow", "prepareToHide", "show", "hide", "reposition"];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      methodToBind = _ref1[_j];
      this.bound[methodToBind] = (function(methodToBind) {
        return function() {
          return _this[methodToBind].apply(_this, arguments);
        };
      })(methodToBind);
    }
    this.activate();
    if (this.options.showOn === "creation") {
      return this.prepareToShow();
    }
  };

  Opentip.prototype._buildContainer = function() {
    this.container = this.adapter.create("<div id=\"opentip-" + this.id + "\" class=\"" + this["class"].container + " " + this["class"].hidden + " " + this["class"].stylePrefix + this.options.className + "\"></div>");
    if (this.options.ajax) {
      this.adapter.addClass(this.container, this["class"].loading);
    }
    if (this.options.fixed) {
      this.adapter.addClass(this.container, this["class"].fixed);
    }
    if (this.options.showEffect) {
      this.adapter.addClass(this.container, "" + this["class"].showEffectPrefix + this.options.showEffect);
    }
    if (this.options.hideEffect) {
      return this.adapter.addClass(this.container, "" + this["class"].hideEffectPrefix + this.options.hideEffect);
    }
  };

  Opentip.prototype._buildElements = function() {
    var headerElement, stemElement, stemOffset, titleElement;
    if (this.options.stem) {
      stemOffset = "-" + this.options.stemSize + "px";
      stemElement = this.adapter.create("<div class=\"stem " + (this.dasherize(this.options.stem)) + "\"><canvas></canvas></div>");
      this.adapter.append(this.container, stemElement);
    }
    this.tooltipElement = this.adapter.create("<div class=\"opentip\"><header></header><div class=\"content\"></div></div>");
    headerElement = this.adapter.find(this.tooltipElement, "header");
    if (this.options.title) {
      titleElement = this.adapter.create("<h1></h1>");
      this.adapter.update(titleElement, this.options.title, this.options.escapeTitle);
      this.adapter.append(headerElement, titleElement);
    }
    if (this.options.ajax) {
      this.adapter.append(this.tooltipElement, this.adapter.create("<div class=\"loading-indicator\"><span>Loading...</span></div>"));
    }
    if (__indexOf.call(this.options.hideTriggers, "closeButton") >= 0) {
      this.adapter.append(headerElement, this.adapter.create("<div class=\"buttons\"><a href=\"javascript:undefined;\" class=\"close\">âœ–</a></div>"));
    }
    this.adapter.append(this.container, this.tooltipElement);
    return this.adapter.append(document.body, this.container);
  };

  Opentip.prototype.setContent = function(content) {
    this.content = content;
    if (this.visible) {
      return this._updateElementContent();
    }
  };

  Opentip.prototype._updateElementContent = function() {
    var contentDiv;
    contentDiv = this.adapter.find(this.container, ".content");
    if (contentDiv != null) {
      if (typeof this.content === "function") {
        this.debug("Executing content function.");
        this.content = this.content(this);
      }
      this.adapter.update(contentDiv, this.content, this.options.escapeHtml);
    }
    return this._storeAndFixDimensions();
  };

  Opentip.prototype._storeAndFixDimensions = function() {
    this.adapter.css(this.container, {
      width: "auto",
      left: "0px",
      top: "0px"
    });
    this.dimensions = this.adapter.dimensions(this.container);
    return this.adapter.css(this.container, {
      width: "" + this.dimensions.width + "px",
      top: "" + this.lastPosition.top + "px",
      left: "" + this.lastPosition.left + "px"
    });
  };

  Opentip.prototype.activate = function() {
    return this._setupObservers("hidden", "hiding");
  };

  Opentip.prototype.deactivate = function() {
    this.debug("Deactivating tooltip.");
    this.hide();
    return this._setupObservers("hidden");
  };

  Opentip.prototype._setupObservers = function() {
    var state, states, trigger, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    states = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    for (_i = 0, _len = states.length; _i < _len; _i++) {
      state = states[_i];
      switch (state) {
        case "showing":
          _ref = this.hideTriggers;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            trigger = _ref[_j];
            this.adapter.observe(trigger.element, trigger.event, this.bound.prepareToHide);
          }
          _ref1 = this.showTriggersWhenHidden;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            trigger = _ref1[_k];
            this.adapter.stopObserving(trigger.element, trigger.event, this.bound.prepareToShow);
          }
          this.adapter.observe((document.onresize != null ? document : window), "resize", this.bound.reposition);
          this.adapter.observe(window, "scroll", this.bound.reposition);
          break;
        case "visible":
          _ref2 = this.showTriggersWhenVisible;
          for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
            trigger = _ref2[_l];
            this.adapter.observe(trigger.element, trigger.event, this.bound.prepareToShow);
          }
          break;
        case "hiding":
          _ref3 = this.showTriggersWhenHidden;
          for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
            trigger = _ref3[_m];
            this.adapter.observe(trigger.element, trigger.event, this.bound.prepareToShow);
          }
          _ref4 = this.hideTriggers;
          for (_n = 0, _len5 = _ref4.length; _n < _len5; _n++) {
            trigger = _ref4[_n];
            this.adapter.stopObserving(trigger.element, trigger.event, this.bound.prepareToHide);
          }
          this.adapter.stopObserving((document.onresize != null ? document : window), "resize", this.bound.reposition);
          this.adapter.stopObserving(window, "scroll", this.bound.reposition);
          break;
        case "hidden":
          _ref5 = this.showTriggersWhenVisible;
          for (_o = 0, _len6 = _ref5.length; _o < _len6; _o++) {
            trigger = _ref5[_o];
            this.adapter.stopObserving(trigger.element, trigger.event, this.bound.prepareToShow);
          }
          break;
        default:
          throw new Error("Unknown state: " + state);
      }
    }
    return null;
  };

  Opentip.prototype.prepareToShow = function() {
    this._abortHiding();
    if (this.visible) {
      return;
    }
    this.debug("Showing in " + this.options.delay + "s.");
    if (this.options.group) {
      Opentip._abortShowingGroup(this.options.group);
    }
    this.preparingToShow = true;
    this._setupObservers("showing");
    this._followMousePosition();
    this.reposition();
    return this._showTimeoutId = this.setTimeout(this.bound.show, this.options.delay || 0);
  };

  Opentip.prototype.show = function() {
    var _this = this;
    this._clearTimeouts();
    if (this.visible) {
      return;
    }
    if (!this._triggerElementExists()) {
      return this.deactivate();
    }
    this.debug("Showing now.");
    if (this.options.group) {
      Opentip._hideGroup(this.options.group);
    }
    this.visible = true;
    this.preparingToShow = false;
    if (this.tooltipElement == null) {
      this._buildElements();
    }
    this._updateElementContent();
    if (this.options.ajax && !this.loaded) {
      this._loadAjax();
    }
    this._searchAndActivateHideButtons();
    this._startEnsureTriggerElement();
    this.adapter.css(this.container, {
      zIndex: Opentip.lastZIndex++
    });
    this._setupObservers("visible", "showing");
    this.reposition();
    this.adapter.removeClass(this.container, this["class"].hiding);
    this.adapter.removeClass(this.container, this["class"].hidden);
    this.adapter.addClass(this.container, this["class"].goingToShow);
    return this.defer(function() {
      var delay;
      _this.setCss3Style(_this.container, {
        "transition-duration": "" + _this.options.showEffectDuration + "s"
      });
      _this.adapter.removeClass(_this.container, _this["class"].goingToShow);
      _this.adapter.addClass(_this.container, _this["class"].showing);
      delay = 0;
      if (_this.options.showEffect && _this.options.showEffectDuration) {
        delay = _this.options.showEffectDuration;
      }
      _this._visibilityStateTimeoutId = _this.setTimeout(function() {
        _this.adapter.removeClass(_this.container, _this["class"].showing);
        return _this.adapter.addClass(_this.container, _this["class"].visible);
      }, delay);
      return _this._activateFirstInput();
    });
  };

  Opentip.prototype._abortShowing = function() {};

  Opentip.prototype.prepareToHide = function() {};

  Opentip.prototype.hide = function() {};

  Opentip.prototype._abortHiding = function() {
    if (this.preparingToHide) {
      this.debug("Aborting hiding");
      this._clearTimeouts();
      this.preparingToHide = false;
      return this._setupObservers("showing");
    }
  };

  Opentip.prototype.reposition = function() {};

  Opentip.prototype._searchAndActivateHideButtons = function() {
    var element, _i, _len, _ref;
    if (__indexOf.call(this.options.hideTriggers, "closeButton") >= 0) {
      _ref = this.adapter.findAll(this.container, ".close");
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i];
        this.hideTriggers.push({
          element: this.adapter.wrap(element),
          event: "click"
        });
      }
      if (this.visible) {
        return this._setupObservers("visible");
      }
    }
  };

  Opentip.prototype._activateFirstInput = function() {
    var input;
    input = this.adapter.unwrap(this.adapter.find(this.container, "input, textarea"));
    return input != null ? typeof input.focus === "function" ? input.focus() : void 0 : void 0;
  };

  Opentip.prototype._followMousePosition = function() {
    if (!this.options.fixed) {
      return this.adapter.observe(document.body, "mousemove", this.bound.reposition);
    }
  };

  Opentip.prototype._stopFollowingMousePosition = function() {
    if (!this.options.fixed) {
      return this.adapter.stopObserving(document.body, "mousemove", this.bound.reposition);
    }
  };

  Opentip.prototype._clearShowTimeout = function() {
    return clearTimeout(this._showTimeoutId);
  };

  Opentip.prototype._clearHideTimeout = function() {
    return clearTimeout(this._hideTimeoutId);
  };

  Opentip.prototype._clearTimeouts = function() {
    clearTimeout(this._visibilityStateTimeoutId);
    this._clearShowTimeout();
    return this._clearHideTimeout();
  };

  Opentip.prototype._triggerElementExists = function() {
    var el;
    el = this.adapter.unwrap(this.triggerElement);
    while (el.parentNode) {
      if (el.parentNode.tagName === "BODY") {
        return true;
      }
      el = el.parentNode;
    }
    return false;
  };

  Opentip._loadAjax = function() {
    throw new Error("Not supported yet.");
  };

  Opentip.prototype._ensureTriggerElement = function() {
    if (!this._triggerElementExists()) {
      this.deactivate();
      return this._stopEnsureTriggerElement();
    }
  };

  Opentip.prototype._ensureTriggerElementInterval = 1000;

  Opentip.prototype._startEnsureTriggerElement = function() {
    var _this = this;
    return this._ensureTriggerElementTimeoutId = setInterval((function() {
      return _this._ensureTriggerElement();
    }), this._ensureTriggerElementInterval);
  };

  Opentip.prototype._stopEnsureTriggerElement = function() {
    return clearInterval(this._ensureTriggerElementTimeoutId);
  };

  return Opentip;

})();

vendors = ["khtml", "ms", "o", "moz", "webkit"];

Opentip.prototype.setCss3Style = function(element, styles) {
  var prop, value, vendor, _i, _len, _results;
  element = this.adapter.unwrap(element);
  _results = [];
  for (prop in styles) {
    if (!__hasProp.call(styles, prop)) continue;
    value = styles[prop];
    for (_i = 0, _len = vendors.length; _i < _len; _i++) {
      vendor = vendors[_i];
      element.style["-" + vendor + "-" + prop] = value;
    }
    _results.push(element.style[prop] = value);
  }
  return _results;
};

Opentip.prototype.defer = function(func) {
  return setTimeout(func, 0);
};

Opentip.prototype.setTimeout = function(func, seconds) {
  return setTimeout(func, seconds ? seconds * 1000 : 0);
};

Opentip.prototype.ucfirst = function(string) {
  if (string == null) {
    return "";
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
};

Opentip.prototype.dasherize = function(string) {
  return string.replace(/([A-Z])/g, function(_, char) {
    return "-" + (char.toLowerCase());
  });
};

Opentip.prototype.sanitizePosition = function(position) {
  var horizontalPosition, i, verticalPosition, _i, _j, _len, _len1, _ref, _ref1;
  if (typeof position === "boolean") {
    return position;
  }
  if (!position) {
    return null;
  }
  position = position.toLowerCase();
  _ref = ["top", "bottom"];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    i = _ref[_i];
    if (~position.indexOf(i)) {
      verticalPosition = i;
    }
  }
  _ref1 = ["left", "right"];
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    i = _ref1[_j];
    if (~position.indexOf(i)) {
      horizontalPosition = i;
    }
  }
  if (verticalPosition != null) {
    horizontalPosition = this.ucfirst(horizontalPosition);
  }
  position = "" + (verticalPosition != null ? verticalPosition : "") + (horizontalPosition != null ? horizontalPosition : "");
  if (Opentip.position[position] == null) {
    throw "Unknown position: " + position;
  }
  return position;
};

Opentip.prototype.flipPosition = function(position) {
  var flippedIndex, positionIdx;
  positionIdx = Opentip.position[position];
  flippedIndex = (positionIdx + 4) % 8;
  return Opentip.positions[flippedIndex];
};

Opentip.prototype.debug = function() {
  var args;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  if (Opentip.debug && ((typeof console !== "undefined" && console !== null ? console.debug : void 0) != null)) {
    args.unshift("#" + this.id + " |");
    return console.debug.apply(console, args);
  }
};

Opentip.version = "2.0.0-dev";

Opentip.debug = false;

Opentip.lastId = 0;

Opentip.lastZIndex = 100;

Opentip.tips = [];

Opentip._abortShowingGroup = function() {};

Opentip._hideGroup = function() {};

Opentip.adapters = {};

Opentip.adapter = null;

Opentip.documentIsLoaded = false;

Opentip.positions = ["top", "topRight", "right", "bottomRight", "bottom", "bottomLeft", "left", "topLeft"];

Opentip.position = {};

_ref = Opentip.positions;
for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
  position = _ref[i];
  Opentip.position[position] = i;
}

Opentip.styles = {
  standard: {
    title: void 0,
    escapeTitle: true,
    className: "standard",
    stem: false,
    delay: null,
    hideDelay: 0.1,
    fixed: false,
    showOn: "mouseover",
    hideTrigger: "trigger",
    hideTriggers: [],
    hideOn: null,
    offset: [0, 0],
    containInViewport: true,
    autoOffset: true,
    showEffect: "appear",
    hideEffect: "fade",
    showEffectDuration: 0.3,
    hideEffectDuration: 0.2,
    stemSize: 8,
    tipJoint: "top left",
    target: null,
    targetJoint: null,
    ajax: false,
    group: null,
    escapeHtml: false,
    style: null
  },
  slick: {
    className: "slick",
    stem: true
  },
  rounded: {
    className: "rounded",
    stem: true
  },
  glass: {
    className: "glass"
  }
};

Opentip.defaultStyle = "standard";
